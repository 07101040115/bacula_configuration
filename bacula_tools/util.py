from __future__ import print_function
from . import *
import bacula_tools
import re, os, sys, filecmp

# Extra stuff needed for the console/daemon tools
import socket, hmac, base64, hashlib, time
from random import randint
from struct import pack, unpack

# {{{ guess_os():

os_bits = {
    'bsd': 'FreeBSD',
    'BSD': 'FreeBSD',
    'Macintosh': 'OSX',
    'OS X': 'OSX',
    'apple-darwin': 'OSX',
    'msie': 'Windows',
    'MSIE': 'Windows',
    }

def guess_os():
    agent = os.environ.get('HTTP_USER_AGENT', '')
    environ = os.environ.get('PATH_INFO','')
    for k in os_bits.keys():
        if k in agent or k in environ:
            return os_bits[k]
    return 'Linux'              # Default

# }}}
# {{{ generate_password():

def generate_password():
    length = 44
    password = []
    possible = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890'
    return ''.join(choice(possible) for _ in xrange(length))

# }}}
# {{{ guess_schedule_and_filesets(hostname, os):


def guess_schedule_and_filesets(hostname, os):
    results = []
    for (variable, matcher, fileset, schedule) in _guessing_rules:
        if matcher.match(locals()[variable]): results.append((fileset, schedule))
    return results or _default_rules

# }}}
def generic_option_processor(obj, args, items, boolean=False, dereference=False):
    for key in items:
        if not type(key) == str: key = key[0]
        value = getattr(args, key)
        if value == None: continue
        if value == '': value = None
        try: obj._set(key, value, boolean, dereference)
        except: pass
    return
    
class ConfigFile(object):       # easy config file management
    FILEHEADER = "# This config file generated by %s script.\n#\n#DO NOT EDIT THIS FILE BY HAND\n\n" % sys.argv[0]
    # {{{ __init__(filename)    # file to update (or not, as the case may be)

    def __init__(self, filename):
        self.filename = filename
        self.newfilename = filename + '.new'
        self.fh = open(self.newfilename, 'w')
        self.fh.write(self.FILEHEADER)
        debug_print("Opened %s", self.newfilename)
        return

    # }}}
    # {{{ close(*data):              # Returns True if an actual update happens

    def close(self, *data):
        if data: self.write(*data)
        self.fh.flush()
        self.fh.close()
        try: test_value = filecmp.cmp(self.filename, self.newfilename)
        except: test_value = False
        if test_value:
            os.unlink(self.newfilename)
            debug_print("\t%s doesn't need to be updated", self.filename)
            return False
        debug_print("\tupdating %s", self.filename)
        os.rename(self.newfilename, self.filename)
        return True

# }}}
    # {{{ write(*data): writes data out to the file, appending newlines for each item passed in

    def write(self, *data):
        for line in data:
            self.fh.write(str(line))
            self.fh.write('\n')
        return

# }}}
    
class DbDict(dict):             # base class for all of the things derived from database rows
    brace_re = re.compile(r'\s*(.*?)\s*\{\s*(.*)\s*\}\s*', re.MULTILINE|re.DOTALL)
    name_re = re.compile(r'^\s*name\s*=\s*(.*)', re.MULTILINE|re.IGNORECASE)
    bc = bacula_tools.Bacula_Factory()
    output = []
    prefix = '  '               # Used for spacing out members when printing
    table = 'override me'       # This needs to be overridden in every subclass, before calling __init__

    # {{{ __init__(row={}, string=None): pass in a row (as a dict)
    def __init__(self, row={}, string = None):
        dict.__init__(self)
        self[ID] = None         # Ensure we have an ID
        # This allows flexibility in key setup/declaration, which in turn
        # will allow intelligent groupings to make parse/set/get code
        # somewhat simpler (or at least more clear).
        for x in dir(self):
            if not '_KEYS' in x: continue # Look only for, e.g., NULL_KEYS, SETUP_KEYS, TRUE_KEYS, etc
            for key in getattr(self, x):  # If it's a simple value,
                if type(key) == str: self[key] = None # Assign none
                else: self[key[0]] = key[1]           # Otherwise assume [1] is the desired default  value
        self.update(row)
        if string: self.parse_string(string)
        return

    # }}}
    # {{{ search(string=None, id=None):

    def search(self, string=None, id=None):
        if string:
            new_me = self.bc.value_check(self.table, NAME, string, asdict=True)
        elif not id == None:
            debug_print('tracking down id %s', id)
            new_me = self.bc.value_check(self.table, ID, id, asdict=True)
        else:
            new_me = self.bc.value_check(self.table, NAME, self[NAME], asdict=True)
        try: self.update(new_me[0])
        except Exception as e: pass
        [getattr(self, x)() for x in dir(self) if '_load_' in x]
        return self

    # }}}
    # {{{ delete(): delete it from the database

    def delete(self):
        self.bc.do_sql('DELETE FROM %s WHERE id = %%s' % self.table, self[ID])
        return

# }}}
    # {{{ _set(field, value, boolean=False, dereference=False): handy shortcut for setting and saving values

    def _set(self, field, value, boolean=False, dereference=False):
        debug_print('setting %s to %s, boolean=%s, dereference=%s', field, value, boolean, dereference)
        if boolean:
            if value in ['0', 'no', 'No', 'NO', 'off', 'Off', 'OFF']: value = 0
            else: value = 1
        if dereference:
            value = self._fk_reference(field, value)[ID]
        self[field] = value
        return self._save()

    # }}}
    # {{{ _save(): Save the top-level fileset record
    def _save(self):
        keys = [x for x in self.keys() if not x == ID]
        keys.sort()
        sql = 'update %s set %s where id = %%s' % (self.table,
                                                   ', '.join(['`%s` = %%s' % x for x in keys]))
        values = tuple([self[x] for x in keys] + [self[ID],])
        return self.bc.do_sql(sql, values)
# }}}
    # {{{ _set_name(name): set my name

    def _set_name(self, name):
        row = self.bc.value_ensure(self.table, NAME, name.strip(), asdict=True)[0]
        self.update(row)
        [getattr(self, x)() for x in dir(self) if '_load_' in x]
        return

    # }}}
    # {{{ parse_string(string): Entry point for a recursive descent parser

    def parse_string(self, string):
        '''Populate a new object from a string.
        
        We're cheating and treating this object as a blob.  Also, the
        *_config parameters will potentially be used to tell us to discard
        passwords.  Sigh.
        '''
        g = self.name_re.search(string).groups()
        self._set_name(g[0].strip())
        string = self.name_re.sub('', string)
        data = '\n  '.join([x.strip() for x in string.split('\n') if x])
        self._set(DATA, data)
        return "%s: %s" % (self.table.capitalize(), self[NAME])

    # }}}
    # {{{ _parse_setter(key, c_int=False, dereference=False):

    def _parse_setter(self, key, c_int=False, dereference=False):
        '''Shortcut called by parser for setting values'''
        def rv(value):
            if c_int: self._set(key, int(value[2].strip()), dereference=dereference)
            else: self._set(key, value[2].strip(), dereference=dereference)
        return rv

# }}}
    # {{{ _simple_phrase(key, quoted=True):

    def _simple_phrase(self, key, quoted=True):
        if not type(key) == str: key = key[0]
        if self[key] == None: return
        if 'retention' in key: quoted = False
        if 'size' in key: quoted = False
        if 'bytes' in key: quoted = False
        try:
            int(self[key])
            value = self[key]
        except:
            if quoted: value = '"' + self[key] + '"'
            else: value = self[key]
        self.output.insert(-1,'%s%s = %s' % (self.prefix, key.capitalize(), value))
        return

    # }}}
    # {{{ _yesno_phrase(key, onlytrue=False, onlyfalse=False):

    def _yesno_phrase(self, key, onlytrue=False, onlyfalse=False):
        if not type(key) == str: key = key[0]
        value = self[key]
        if (not value) or value == '0': value = NO
        else: value = YES
        if onlytrue and value == NO: return
        if onlyfalse and value == YES: return
        self.output.insert(-1,'%s%s = %s' % (self.prefix,key.capitalize(), value))
        return

    # }}}
    # {{{ fd(): stub function to make testing a little easier

    def fd(self): return ''

    # }}}
    # {{{ _fk_reference(fk, string=None): Set/get fk-references

    def _fk_reference(self, fk, string=None):
        debug_print('_fk_reference %s: %s, %s' % (fk, string, self[fk]))
        obj = bacula_tools._DISPATCHER[fk.replace('_id','')]()
        if string:
            obj.search(string.strip())
            if not obj[ID]: obj._set_name(string.strip())
            if not self[fk] == obj[ID]: self._set(fk, obj[ID])
        else: obj.search(None, id=self[fk])
        return obj

# }}}

class PList(list):
    '''This bizarre construct takes a phrase and lazily turns it into a
    list that is all the permutations of the phrase with all spaces
    removed.  Further, this list is sorted such that the first element is
    the original phrase, while the last one has no spaces at all.  It's
    kind of a weird thing, but it makes the string parsing much, much more
    compact and efficient.
    '''
    # {{{ __init__(phrase):

    def __init__(self, phrase):
        list.__init__(self)
        self._expand(phrase)
        return

    # }}}
    # {{{ _p2(ary):

    def _p2(self, ary):
        if len(ary) == 1: return ary
        if len(ary) == 2: return [''.join(ary), ' '.join(ary)]
        results = []
        for x in self._p2(ary[1:]):
            results.append(ary[0] + x)
            results.append(ary[0] + ' ' + x)
        return results

    # }}}
    # {{{ _expand(phrase):

    def _expand(self, phrase):
        result = self._p2(phrase.split(' '))
        result.sort()
        self.extend(result)
        return

# }}}
    

class BSock:
    '''Sometimes, you want to talk to various Bacula daemons without the
    overhead of firing up bconsole, particularly since that will involve
    shell interaction as well fun parsing foo.  This will make it a bit
    easier, not to mention making dealing with timeouts a lot more
    mangeable.
    '''
# {{{ __init__(address, password, myname, port, debug=False, timeout=5):
    def __init__(self, address, password, myname, port, timeout=5):
        if not address: address = '127.0.0.1'
        self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connection.settimeout(timeout) # Don't take forever trying to do stuff
        self.log('connecting to: %s' % str((address,port)))
        self.connection.connect((address,port))
        self.password = password
        self.name = myname
        return
# }}}
# {{{ log(msg): Debugging output

    def log(self, msg):
        if DEBUG:
            sys.stderr.write(msg)
            sys.stderr.flush()
        return

    # }}}
# {{{ auth(): authenticate a new connection

    def auth(self):
        '''The bulk of this was written by Matthew Ife, so thanks!'''
        
        self.send("Hello %s calling\n" % (self.name,)) # this is effectively our username
        challenge = self.recv() # Receive the challenge response
        m = re.search("auth cram-md5 (<.+?>)", challenge) # parse the challenge out of the returned string
        chal = m.group(1)
        
        pw = hashlib.md5(self.password).hexdigest()
        self.send(base64.b64encode(hmac.new(pw, chal).digest())[:-2]) # hmac and base64 encode the request

        result = self.recv() # receive response
        if result != "1000 OK auth\n": raise ValueError("Authentication Failed %s" % (result,))# failed

        # send our challenge response
        self.send("auth cram-md5 <%d.%d@%s> ssl=0\n" % (randint(1,99999999), int(time.time()), self.name))
        self.recv()                 # get the response back
        self.send("1000 OK auth\n") # Dont even check the response here!

        # This is basically cheating the protocol spec! :-)
        data = self.recv()
        if not re.match(".* OK.*",data): # auth complete
            raise ValueError("Unexpected packet received %s" % (data,))
        self.auth = True
        return data

    # }}}
# {{{ send(message): send a message to the remote daemon

    def send(self, message):
        ldata = pack('!i',len(message))
        self.connection.send(ldata)
        self.log( 'sending:  (%d) %s\n' % (len(message), message))
        self.connection.send(message)
        return

    # }}}
# {{{ recv(): Get a one line response from the remote daemon

    def recv(self):
        msglen = unpack('!i', self.connection.recv(4))[0]
        if msglen < 0: return ''
        response = self.connection.recv(msglen)
        self.log( 'received: %s' % response)
        return response

    # }}}
# {{{ recv_all(): receive a multi-line response from the remote daemon

    def recv_all(self):
        """Gets all lines of a request"""
        r = ""
        s = self.recv()
        while s:
            r += s
            s = self.recv()
        return r

    # }}}
# {{{ version(): request version info from the remote daemon (useless?)

    def version(self):
        self.send('version')
        return self.recv()

    # }}}
# {{{ status(args=''): request status of the remote daemon

    def status(self, args=''):
        if args: self.send('.status %s' % args)
        else: self.send('status')
        return self.recv_all()

    # }}}
# {{{ _time(): format the time for uniqueifying various things

    def _time(self):
        return time.strftime('%F_%H.%M.%S_00')

    # }}}
