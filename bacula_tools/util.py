from . import *
from . import Bacula_Factory
import re, os, sys, filecmp

# {{{ guess_os():

os_bits = {
    'bsd': 'FreeBSD',
    'BSD': 'FreeBSD',
    'Macintosh': 'OSX',
    'OS X': 'OSX',
    'apple-darwin': 'OSX',
    'msie': 'Windows',
    'MSIE': 'Windows',
    }

def guess_os():
    agent = os.environ.get('HTTP_USER_AGENT', '')
    environ = os.environ.get('PATH_INFO','')
    for k in os_bits.keys():
        if k in agent or k in environ:
            return os_bits[k]
    return 'Linux'              # Default

# }}}
# {{{ generate_password():

def generate_password():
    length = 44
    password = []
    possible = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890'
    return ''.join(choice(possible) for _ in xrange(length))

# }}}
# {{{ guess_schedule_and_filesets(hostname, os):


def guess_schedule_and_filesets(hostname, os):
    results = []
    for (variable, matcher, fileset, schedule) in _guessing_rules:
        if matcher.match(locals()[variable]): results.append((fileset, schedule))
    return results or _default_rules

# }}}

class ConfigFile(object):       # easy config file management
    FILEHEADER = "# This config file generated by %s script.\n#\n#DO NOT EDIT THIS FILE BY HAND\n\n" % sys.argv[0]
    # {{{ __init__(filename)    # file to update (or not, as the case may be)

    def __init__(self, filename):
        self.filename = filename
        self.newfilename = filename + '.new'
        self.fh = open(self.newfilename, 'w')
        self.fh.write(self.FILEHEADER)
        debug_print("Opened %s", self.newfilename)
        return

    # }}}
    # {{{ close(*data):              # Returns True if an actual update happens

    def close(self, *data):
        if data: self.write(*data)
        self.fh.flush()
        self.fh.close()
        try: test_value = filecmp.cmp(self.filename, self.newfilename)
        except: test_value = False
        if test_value:
            os.unlink(self.newfilename)
            debug_print("\t%s doesn't need to be updated", self.filename)
            return False
        debug_print("\tupdating %s", self.filename)
        os.rename(self.newfilename, self.filename)
        return True

# }}}
    # {{{ write(*data): writes data out to the file, appending newlines for each item passed in

    def write(self, *data):
        for line in data:
            self.fh.write(line)
            self.fh.write('\n')
        return

# }}}
    
class DbDict(dict):             # base class for all of the things derived from database rows
    comment_re = re.compile(r'#.*', re.MULTILINE)
    semicolon_re = re.compile(r';', re.MULTILINE)

    # {{{ __init__(row): pass in a row (as a dict)
    def __init__(self, row):
        dict.__init__(self, row)
        self.table = 'override me'
        self.field = 'override me'
        return

    # }}}
    def _regularize_string(self, string):
        return self.semicolon_re.sub('\n', self.comment_re.sub('', string))
    def search(self, string):
        bc = Bacula_Factory()
        new_me = bc.value_check(self.table, self.field, string, asdict=True)
        try: self.update(new_me[0])
        except Exception, e: pass
        return self

class Director(DbDict):
    # {{{ __init__(row):

    def __init__(self, row):
        DbDict.__init__(self, row)
        return

# }}}
    # {{{ __str__(): useful for printing out the Director clause needed by bconsole

    def __str__(self):
        bc = Bacula_Factory()
        myself = bc.get_clients(specific=self[HOSTNAME])[0]
        return '''Director {
  Name = %(hostname)s
  DIRport = 9101
  address = %(address)s
  Password = "%(password)s"
}
''' % myself

# }}}
    # {{{ dir_conf(bc): bc == a valid Bacula_Config object

    def dir_conf(self, bc):
        # This is mostly boilerplate, but still
        me_as_client = bc.get_clients(self[HOSTNAME])[0]
        self[PASSWORD] = me_as_client[PASSWORD]
        data = '''
Director {
  Name = %(hostname)s
    DIRport = 9101                # where we listen for UA connections
    QueryFile = "/etc/bacula/scripts/query.sql"
    WorkingDirectory = "/var/lib/bacula"
    PidDirectory = "/var/run/bacula"
    Maximum Concurrent Jobs = 100
    Password = "%(password)s"
    Messages = Standard
    Scripts Directory = /etc/bacula/scripts
}

Catalog {
  Name = MyCatalog
  DB Name = %(dbname)s
  user = %(dbuser)s
  password = "%(dbpassword)s"
  DB Address = %(dbaddress)s
}

Messages {
  Name = Standard
  mailcommand = "/usr/local/bacula/zabbix.bacula %%c bacula@llnw.com %%t %%e %%l"
  operatorcommand = "/usr/lib/bacula/bsmtp -h localhost -f \"\(Bacula\) bacula@llnw.com\" -s \"Bacula: Intervention needed for %%j\" %%r"
  mail = bacula@llnw.com = all, !skipped
  operator = hkugler@llnw.com, bacula@llnw.com, bgallew@llnw.com = mount
  console = all, !skipped, !saved
  syslog = all, !skipped
  catalog = all, !skipped, !saved
}
'''
        return data % self

# }}}
        
class StorageDaemon(DbDict):
    # {{{ __init__(row, timespan, directors):

    def __init__(self, row, timespan, directors):
        DbDict.__init__(self, row)
        self[TIMESPAN] = timespan
        self.directors = directors
        return

    # }}}
    # {{{ print_pool_storage():

    def print_pool_storage(self):
        return '''
Pool {
  Name = %(hostname)s
  Pool Type = Backup
  Recycle = yes
  AutoPrune = yes
  Volume Retention = %(timespan)s
  Maximum Volume Jobs = 1
  Label Format = %(hostname)s-
  Action On Purge = Truncate
}

Storage {
  Name = %(hostname)s
  Address = %(address)s
  SDPort = 9103
  Password = %(password)s
  Device = %(hostname)s
  Media Type = %(hostname)s
  Maximum Concurrent Jobs = 1
}
''' % self

    # }}}
    # {{{ print_device_storage():

    def print_device_storage(self):
        if self[DIRECTOR] == None:
            for d in self.directors:
                if d[PRIMARY_DIR]: self[DIRECTOR_NAME] = d[HOSTNAME]
        else:
            for d in self.directors:
                if d[DIRID] == self[DIRECTOR]: self[DIRECTOR_NAME] = d[HOSTNAME]
        return '''
Storage {
  Name = %(hostname)s
  SDPort = 9103
  WorkingDirectory = "/var/lib/bacula"
  Pid Directory = "/var/run/bacula"
  Maximum Concurrent Jobs = 60
}

Messages {
  Name = Standard
  director = %(director_name)s = all
}
''' % self

# }}}
    # {{{ print_director_access():

    def print_director_access(self):
        result = []
        for d in self.directors:
            result.append('''
Director {
  Name = %s
  Password = %s
}
''' % (d[HOSTNAME], self[PASSWORD]))
        return '\n'.join(result)

    # }}}
                          
class Client(DbDict):           # Should do lots of client stuff all in one place
    # {{{ __init__(row):
    # These two values have to do with formatting the output and are related.
    fmt = '%31s: %s'
    spacer = '\n'+33*' '
    def __init__(self, row):
        DbDict.__init__(self, row)
        bc = Bacula_Factory()
        for x in bc.get_storage_daemons():
            if x[HOSTNAME] == self[STORAGESERVER]:
                self[STORAGESERVERADDRESS] = x[ADDRESS]
                self[STORAGEPASSWORD] = x[PASSWORD]
        self['message_set'] = 'Standard'
        directors = bc.get_directors()
        imadirector = False
        shorthost = os.uname()[1].split('.')[0]
        for d in directors:
            if shorthost in d[HOSTNAME]: imadirector = True
            if not self[DIRECTOR] and d[PRIMARY_DIR]: self[DIRECTOR] = d[DIRID]
            if self[DIRECTOR] == d[DIRID]:
                self[DIRECTOR_NAME] = d[HOSTNAME]
                self[DBNAME] = d[DBNAME]
                self[DBUSER] = d[DBUSER]
                self[DBPASSWORD] = d[DBPASSWORD]
                self[DBADDRESS] = d[DBADDRESS]

        # This is kind of complicated.  If we are running this on an actual
        # director, then we should check to see if the Client's director
        # matches the current host.  If not, mark it disabled (Clients are
        # always disabled on every director but the one to which they
        # belong)
        if self[BACULAENABLED] and imadirector:
            my_director = [x for x in directors if shorthost in x[HOSTNAME]]
            if self[DIRECTOR] != my_director[DIRID]: self[BACULAENABLED] = 0
        self['bootstrapdir'] = Bacula_Config.BOOTSTRAPDIR
        self[ENABLED] = YES if self[BACULAENABLED] else NO
        self[POOL] = self[STORAGESERVER]
        return

    # }}}
    # {{{ __str__(): nice string representation

    def __str__(self):
        result = []
        # This overrides the work in __init__ because it ignores the director information as being irrelevant.
        if self[BACULAENABLED] != 0: self[ENABLED] = 'yes'
        else: self[ENABLED] = 'no'
        result.append(self.fmt % (HOSTNAME.capitalize(), '%s (%s)' % (self[HOSTNAME], self[ADDRESS])))
        for key in (HOSTID, ENABLED, FILESET, SCHEDULE, PRIORITY, STORAGESERVER, OS, FILERETENTION, JOBRETENTION, SERVICE, OWNERS, LASTUPDATED):
            result.append(self.fmt % (key.capitalize(), self[key]))

        for key in (BEGIN, END, FAILURE):
            if self[key]: result.append(self.fmt % ('%s Script' % key.capitalize(), self[key]))

        if self[NOTES]: result.append(self.fmt % ('Host Notes', self[NOTES].replace('\n', self.spacer)))
        bacula = Bacula_Factory()
        if self[SERVICE]: service_notes = bacula.get_column('notes', 'service = %s', self[SERVICE], dbtable='service_notes')
        else: service_notes = bacula.get_column('notes', 'service is NULL', dbtable='service_notes')
        if service_notes:
            service_string = '\n'.join(service_notes).replace('\n', self.spacer)
            result.append(self.fmt % ('Service Notes (%s)' % self[SERVICE], service_string))

        return '\n'.join(result)

    # }}}
    # {{{ client_conf():

    def client_conf(self):
        return '''
Client {
  Name = %(hostname)s
  Address = %(address)s
  Catalog = MyCatalog
  Password = %(password)s
  File Retention = %(file_retention)s
  Job Retention = %(job_retention)s
  AutoPrune = yes
}
''' % self

    # }}}
    # {{{ client_device():

    def client_device(self):
        return '''
Device {
  Name = %(hostname)s-%(fileset)s
  Media Type = %(hostname)s-%(fileset)s
  Archive Device = /data/bacula
  LabelMedia = yes;
  Random Access = yes;
  AutomaticMount = yes;
  RemovableMedia = no;
  AlwaysOpen = no;
}
''' % self

    # }}}
    # {{{ client_storage():

    def client_storage(self):
        return '''
Storage {
  Name = %(hostname)s-%(fileset)s
  Address = %(storageserveraddress)s
  SDPort = 9103
  Password = %(storagepassword)s
  Device = %(hostname)s-%(fileset)s
  Media Type = %(hostname)s-%(fileset)s
  Maximum Concurrent Jobs = 1
}
''' % self

    # }}}
    # {{{ client_job():
    
    def client_job(self):
        self['script'] = ''.join([self.script(x) for x in ('begin', 'end', 'failure')])
        return '''
Job {
  Name = %(hostname)s-%(fileset)s
  Client = %(hostname)s
  Enabled = %(enabled)s
  Storage = %(hostname)s-%(fileset)s
  Write Bootstrap = \"%(bootstrapdir)s/%(hostname)s%(fileset)s.bsr\"
  Priority = %(priority)s
  Maximum Concurrent Jobs = 1
  Type = Backup
  Level = Incremental
  FileSet = %(fileset)s
  Schedule = %(schedule)s
  Messages = %(message_set)s
  Pool = %(pool)s
  Rerun Failed Levels = yes
  Allow Mixed Priority = yes
%(script)s
}
''' % self

# }}}
    # {{{ client_verify_job():
    
    def client_verify_job(self):
        if 'Snap' in self[FILESET]: return ''
        return '''
Job {
  Name = %(hostname)s-%(fileset)s-Verify
  Client = %(hostname)s
  Enabled = Yes
  Storage = %(hostname)s-%(fileset)s
  Priority = %(priority)s
  Maximum Concurrent Jobs = 1
  Type = Verify
  Level = VolumeToCatalog
  Verify Job = %(hostname)s-%(fileset)s
  FileSet = %(fileset)s
  Messages = %(message_set)s
  Pool = %(pool)s
  Allow Mixed Priority = yes
}
''' % self

# }}}
    # {{{ script(word):

    def script(self, word):
        s = self[word]
        if not s: return ''
        s = s % self
        sWhen = 'After'
        sFail = 'No'
        sExtra = ''
        if word == 'begin':
            sWhen = 'Before'
            sExtra = "\t\tFailJobOnError = Yes\n"
        if word == 'failure':
            sExtra = "\t\tRunsOnSuccess = No\n"
            sFail = YES
        return "\tRun Script {\n\t\tCommand = \"%(s)s\"\n\t\tRunsWhen = %(sWhen)s\n\t\tRunsOnFailure = %(sFail)s\n\t\tRunsOnClient = Yes\n%(sExtra)s\t}\n" % locals()

# }}}
    # {{{ toggle_enabled(): toggle whether backups are enabled for this client/job

    def toggle_enabled(self):
        new_value = 0
        if self[BACULAENABLED] == 0: new_value = 1
        bc = Bacula_Factory()
        sql = 'update %s set bacula_enabled = %%s where hostid = %%s' % DBTABLE
        bc.safe_do_sql(sql, (new_value, self[HOSTID]))
        self[BACULAENABLED] = new_value
        return

# }}}
    # {{{ change(field, value): Update the value of a field

    def change(self, field, value):
        bc = Bacula_Factory()
        sql = 'update %s set %s = %%s where hostid = %%s' % (DBTABLE, field)
        bc.safe_do_sql(sql, (value, self[HOSTID]))
        self[field] = value
        return

# }}}
    # {{{ update_service_notes(text, replace=False): Update the value of a field

    def update_service_notes(self, text, replace=False):
        bc = Bacula_Factory()
        if replace:
            if self[SERVICE]: bc.safe_do_sql('DELETE FROM service_notes WHERE service = %s', self[SERVICE])
            else: bc.safe_do_sql('DELETE FROM service_notes WHERE service IS NULL')
        if not text: return
        sql = 'INSERT INTO service_notes (service, notes) VALUES (%s, %s)'
        for line in text.split('\n'):
            bc.safe_do_sql(sql, (self[SERVICE], line))
        return

# }}}
    # {{{ add_job(args): Add a job instead of updating an existing job.  Default values from the current job

    def add_job(self, args):
        if args.fileset: self[FILESET] = args.fileset
        if args.file_retention: self[FILERETENTION] = args.file_retention
        if args.job_retention: self[JOBRETENTION] = args.job_retention
        if args.notes: self[NOTES] = args.notes
        if args.owners: self[OWNERS] = args.owners
        if args.priority: self[PRIORITY] = args.priority
        if args.schedule: self[SCHEDULE] = args.schedule
        if args.service: self[SERVICE] = args.service
        if args.script_begin: self[BEGIN] = args.script_begin
        if args.script_end: self[END] = args.script_end
        if args.script_fail: self[FAILURE] = args.script_fail
        if args.toggle: self[BACULAENABLED] =  1 if self[BACULAENABLED] == 0 else 0
        print self
        bc = Bacula_Factory()
        sql = '''INSERT INTO bacula_hosts
                 (hostname, address, storageserver, password, fileset,
                  bacula_enabled, priority, schedule, os, notes, db, begin,
                  end, failure, file_retention, job_retention, director,
                  owners, services)
                 VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'''
        data = [self[HOSTNAME], self[ADDRESS], self[STORAGESERVER],
                self[PASSWORD], self[FILESET], self[BACULAENABLED],
                self[PRIORITY], self[SCHEDULE], self[OS], self[NOTES],
                self[DB], self[BEGIN], self[END], self[FAILURE],
                self[FILERETENTION], self[JOBRETENTION], self[DIRECTOR],
                self[OWNERS], self[SERVICE]
                ]
        try:
            bc.do_sql(sql, data)
            print 'New job created for', self[HOSTNAME]
        except:
            print 'Unable to create the job'
            pass             # This will happen under lots of circumstances

        # }}}
    # {{{ file_daemon_conf(): return the bacula-fd.conf data

    def file_daemon_conf(self):
        retval = []
        bc = Bacula_Factory()
        for d in bc.get_directors():
            retval.append('''Director {
	Name = %s
	Password = "%s"
}
''' % (d[HOSTNAME], self[PASSWORD]))
        self['workdir'] = WORKING_DIR[self[OS]]
        retval.append('''FileDaemon {
	Name = %(hostname)s
	FDport = 9102
	WorkingDirectory = %(workdir)s
	Pid Directory = /var/run
	Maximum Concurrent Jobs = 20
}

Messages {
	Name = Standard
	director = %(director_name)s = all, !skipped, !restored
}
''' % self)
        return '\n'.join(retval)

    # }}}
